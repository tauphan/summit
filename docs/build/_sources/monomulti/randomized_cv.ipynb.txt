{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Randomized example selection for classification\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Train/test split generation "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The train/test splits are generated in the `execution.genSplits` function. It's task is to generate an train/test split for each statistical itetarion. In order to do that, it is fed by the following inputs \n",
    "* `labels` are the data labels for all the dataset, \n",
    "* `splitRatio` is a real number giving the ratio |test|/|all|,\n",
    "* `statsIterRandomStates` is a list of `numpy` random states used to generate reproductible pseudo-random numbers\n",
    "\n",
    "The main operation in this function is done by the `sklearn.model_selection.StratifiedShuffleSplit` function which returns folds that are made by preserving the percentage of samples for each class.\n",
    "In this case we askittosplit the dataset in two subsets with the asked test size. It then returns a shuffled train/test split while preserving the percentage of samples for each class.\n",
    "We store the examples indices in two `np.array`s called `trainIndices` and `testIndices`\n",
    "All the algortihms will then train (hyper-parameters cross-validation & learning) on the trainIndices.  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def genSplits(labels, splitRatio, statsIterRandomStates):\n",
    "    \"\"\"Used to gen the train/test splits using one or multiple random states\n",
    "    classificationIndices is a list of train/test splits\"\"\"\n",
    "    indices = np.arange(len(labels))\n",
    "    splits = []\n",
    "    for randomState in statsIterRandomStates:\n",
    "        foldsObj = sklearn.model_selection.StratifiedShuffleSplit(n_splits=1,\n",
    "                                                                  random_state=randomState,\n",
    "                                                                  test_size=splitRatio)\n",
    "        folds = foldsObj.split(indices, labels)\n",
    "        for fold in folds:\n",
    "            train_fold, test_fold = fold\n",
    "        trainIndices = indices[train_fold]\n",
    "        testIndices = indices[test_fold]\n",
    "        splits.append([trainIndices, testIndices])\n",
    "\n",
    "    return splits"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Multiclass problems"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To be able to use the platform on multiclass problems, a one-versus-one method is implemented. \n",
    "In orderto use one-versus-one we need to modify the train/test splits generated by the previouslydescribed founction. \n",
    "If the problem the platformis asked to resolve is multiclass then, it will generate all the possible two-class combinations to divide the main problem in multiple biclass ones. \n",
    "In order to adapt each split, the `genMulticlassLabels` function will create new train/test splits by : \n",
    "* Generating an `oldIndices` list containing all the examples indices that have their label in the combination\n",
    "* Generate a new train split by selecting only the indices of `trainIndices` that have their labels in the combination.\n",
    "* Do the samething for the test indices\n",
    "* Copy the old `testIndices` variable in a new one called `testIndicesMulticlass` that will be used to predict on the entire dataset once the algorithm has learn to distinguish two classes\n",
    "* Generate a new `label` array by replacing all the labels that are not in the combination by -100 to flag them as unseen labels during the training phase. \n",
    "\n",
    "Then the function will return a triplet : \n",
    "* `multiclassLabels` is a list containing, for each combination, the newly generated labels with ones and zeros for each of the labels in the combination and -100 for the others.\n",
    "* `labelsIndices` is a list contaningall the combinations,\n",
    "* `indicesMulticlass` is a list containig triplets for each statistical iteration :\n",
    "    * `trainIndices` are the indices used for training that were picked only in the two classes of the combination (at the second step of the previous list),\n",
    "    * `testIndices` are the indices used for testing the biclass-generalization capacity of each biclass classifier learned on `trainIndices` that were picked only in the two classes of the combination (at the third step of the previous list),\n",
    "    * `tesIndicesMulticlass` are the indices described at the fourth setp of the previous list. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Cross-validation folds "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "The cross validation folds are generated using a `StratifiedKFold` object, for the `sklearn.model_selection` library. \n",
    "* For all the **monoview** algorithms, these objects (one for each statistical iteration) are then fed in a `sklearn.model_selection` `RandomisedSearchCV` object. So we don't have any custom stuff about cross-vaildation folds in the monoview case\n",
    "* In the **multiview** case, they are used in the `utils.HyperParametersSearch` module, in the `randomizedSearch` function. In this case, they are used to split the learning set with `multiviewFolds = KFolds.split(learningIndices, labels[learningIndices])` and then used in `for trainIndices, testIndices in multiviewFolds:`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    ""
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python3",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2.0
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "2.7.13"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
